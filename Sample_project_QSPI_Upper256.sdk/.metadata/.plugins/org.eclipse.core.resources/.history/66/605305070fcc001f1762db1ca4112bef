#if(1)  //----------------------   S: Header Define What Is This File?
#endif  //----------------------   E: Header Define What Is This File?

#if(1)  //----------------------   S: Header Include
#include "Zynq7020.h"
#endif  //----------------------   E: Header Incloud

#if(1)  //----------------------   S: General
    void Correct_Serial_Number(void){
        ReadMyCfg.Serial=Correct_Serial_Number_Specific(ReadMyCfg.Serial);
    }
    uint32_t Correct_Serial_Number_Specific(int serial_Fuck){
	    if(serial_Fuck<1000000 && serial_Fuck>0)
	    	serial_Fuck+=Const_For_Vivado;
	    return serial_Fuck;
    }
    void Zynq7020_Init(void){

        Glb_common_PS0_PS1=(common_PS0_PS1*)0xFFFF0000;

        TcpFastTmrFlag=0;
        TcpSlowTmrFlag=0;
    }
    void Detect_Main_Version(void){
        Set_Main_IP(Version_SV0, 1000);
        usleep(1000);
        Main_IP_Shift_Register_Vivado_Detect_Ver = AssignFromSV_Single_data(W_I_Rec_165_VP_V1);
        Main_Version = ((Main_IP_Shift_Register_Vivado_Detect_Ver>>8) & 0xff);
        if(Main_Version==255 || Main_Version==0){
            Main_Version=1;
        }
        if(Main_Version==6){
            Main_Version=7;
        }
        Set_Main_IP(Version_SV0, Main_Version);
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("Fuck2: Main Version:%d\r\n", Main_Version); Delay_Xil_Printf;}
    }
    int8_t IsGreaterOrEqual(double x1, double x2) {
        return x1 - x2 > -PercisionCompare;
    }
    int8_t IsLessOrEqual(double x1, double x2) {
        return x1 - x2 < PercisionCompare;
    }
    int8_t IsEqual(double x1, double x2) {
        return (x1 - x2 > -PercisionCompare) && (x1 - x2 < PercisionCompare);
    }
    int32_t Calculate_Calib(double x1, double x2, double y1, double y2, double x){
        if(x2==x1)
            return 0;
        return y1+(y2-y1)*(x-x1)/(x2-x1);
    }
#endif  //----------------------   E: General
#if(1)  //----------------------   S: LED
    void Set_ALL_LED_Color_To_FPGA(void){
        for(int next_Led_i=0; next_Led_i<16; next_Led_i++){
            uint32_t Main_IP_Temp=0;
            for(int next_Led_j=0; next_Led_j<4; next_Led_j++){
                Main_IP_Temp=Main_IP_Temp+
                        (LED_Data[4*next_Led_i+next_Led_j][0]<<(next_Led_j*8+5))+
                        (LED_Data[4*next_Led_i+next_Led_j][1]<<(next_Led_j*8+3))+
                        (LED_Data[4*next_Led_i+next_Led_j][2]<<(next_Led_j*8+0));
            }
            switch(next_Led_i){
                case  0: Set_Main_IP(RGB_LED_Data00_SV52 , Main_IP_Temp); break;
                case  1: Set_Main_IP(RGB_LED_Data01_SV53 , Main_IP_Temp); break;
                case  2: Set_Main_IP(RGB_LED_Data02_SV54 , Main_IP_Temp); break;
                case  3: Set_Main_IP(RGB_LED_Data03_SV55 , Main_IP_Temp); break;
                case  4: Set_Main_IP(RGB_LED_Data04_SV56 , Main_IP_Temp); break;
                case  5: Set_Main_IP(RGB_LED_Data05_SV57 , Main_IP_Temp); break;
                case  6: Set_Main_IP(RGB_LED_Data06_SV58 , Main_IP_Temp); break;
                case  7: Set_Main_IP(RGB_LED_Data07_SV59 , Main_IP_Temp); break;
                case  8: Set_Main_IP(RGB_LED_Data10_SV236, Main_IP_Temp); break;
                case  9: Set_Main_IP(RGB_LED_Data11_SV237, Main_IP_Temp); break;
                case 10: Set_Main_IP(RGB_LED_Data12_SV238, Main_IP_Temp); break;
                case 11: Set_Main_IP(RGB_LED_Data13_SV239, Main_IP_Temp); break;
                case 12: Set_Main_IP(RGB_LED_Data14_SV240, Main_IP_Temp); break;
                case 13: Set_Main_IP(RGB_LED_Data15_SV241, Main_IP_Temp); break;
                case 14: Set_Main_IP(RGB_LED_Data16_SV242, Main_IP_Temp); break;
                case 15: Set_Main_IP(RGB_LED_Data17_SV243, Main_IP_Temp); break;
            }
        }
    }
    void LED_Check_Calibration_And_Set(void){
        if(ReadMyCfg.LEDs_Calibration[0]<50 || ReadMyCfg.LEDs_Calibration[0]>150 ||
            ReadMyCfg.LEDs_Calibration[1]<15 || ReadMyCfg.LEDs_Calibration[1]>40  ||
            ReadMyCfg.LEDs_Calibration[2]<55 || ReadMyCfg.LEDs_Calibration[2]>95  ||
            ReadMyCfg.LEDs_Calibration[3]< 0 || ReadMyCfg.LEDs_Calibration[3]>10  ||
            ReadMyCfg.LEDs_Calibration[4]< 0 || ReadMyCfg.LEDs_Calibration[4]>10  ||
            ReadMyCfg.LEDs_Calibration[5]< 0 || ReadMyCfg.LEDs_Calibration[5]>10){
            ReadMyCfg.LEDs_Calibration[0]=100;
            ReadMyCfg.LEDs_Calibration[1]=28;
            ReadMyCfg.LEDs_Calibration[2]=70;
            ReadMyCfg.LEDs_Calibration[3]=3;
            ReadMyCfg.LEDs_Calibration[4]=1;
            ReadMyCfg.LEDs_Calibration[5]=3;
             /*----bib bib----*/if(Flag_Send_and_Recive_Serial!=1) {xil_printf("Bib Bib: LEDs_Calibration\r\n"); Delay_Xil_Printf;}
             EEPROMWriteConfig(WriteMode_LEDsCalibration, 1);
        }
    }
#endif  //----------------------   E: General
#if(1)  //----------------------   S: Calibration
    void EEPROMReadConfig(void){
        EEPROM1_Flash0_Read(1000,0,(void *)&(ReadMyCfg.Serial), MODE_8_BIT,4, 1-MMC_Flash_FlashOk1_FlashNotOk0); Correct_Serial_Number();
        EEPROM1_Flash0_Read(1000,1,(void *)&(ReadMyCfg.ClockCalibration), MODE_8_BIT,4, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        EEPROM1_Flash0_Read(1000,2,(void *)ReadMyCfg.IPConfig, MODE_8_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        EEPROM1_Flash0_Read(1000,3,(void *)&(ReadMyCfg.Port), MODE_8_BIT,2, 1-MMC_Flash_FlashOk1_FlashNotOk0);

        EEPROM1_Flash0_Read(1000,18,(void *)&(ReadMyCfg.MinVersion), MODE_32_BIT,1, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        EEPROM1_Flash0_Read(1000,19,(void *)&(ReadMyCfg.MAC), MODE_8_BIT,6, 1-MMC_Flash_FlashOk1_FlashNotOk0);

        // ----------------- S: Analog Output -> DAC Main
        EEPROM1_Flash0_Read(1000,31,(void *)(ReadMyCfg.Analog_Output_DAs_Main+0),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,32,(void *)(ReadMyCfg.Analog_Output_DAs_Main+16),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0);  //------
        EEPROM1_Flash0_Read(1000,33,(void *)(ReadMyCfg.Analog_Output_DAs_Main+32),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        // ----------------- E: Analog Output -> DAC Main

        // ----------------- S: Analog Output -> ADC DC Cross/Current of Voltage
        EEPROM1_Flash0_Read(1000,34,(void *)(ReadMyCfg.Analog_Output_ADs_DC_Cros+0),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,35,(void *)(ReadMyCfg.Analog_Output_ADs_DC_Cros+16),MODE_32_BIT,8, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        // ----------------- E: Analog Output -> ADC DC Cross/Current of Voltage

        // ----------------- S: Binary Input
        EEPROM1_Flash0_Read(1000,36,(void *)(ReadMyCfg.Binary_Input+0),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,37,(void *)(ReadMyCfg.Binary_Input+16),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,38,(void *)(ReadMyCfg.Binary_Input+32),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,39,(void *)(ReadMyCfg.Binary_Input+48),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,40,(void *)(ReadMyCfg.Binary_Input+64),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,41,(void *)(ReadMyCfg.Binary_Input+80),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,42,(void *)(ReadMyCfg.Binary_Input+96),MODE_32_BIT,3, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        // ----------------- E: Binary Input

        // ----------------- S: Analog Input
        EEPROM1_Flash0_Read(1000,43,(void *)(ReadMyCfg.Analog_Input+0),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,44,(void *)(ReadMyCfg.Analog_Input+16),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,45,(void *)(ReadMyCfg.Analog_Input+32),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,46,(void *)(ReadMyCfg.Analog_Input+48),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,47,(void *)(ReadMyCfg.Analog_Input+64),MODE_32_BIT,8, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        // ----------------- E: Analog Input

        // ----------------- S: Analog Output -> DAC Cross
        EEPROM1_Flash0_Read(1000,50,(void *)(ReadMyCfg.Analog_Output_DAs_Cros+ 0),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,51,(void *)(ReadMyCfg.Analog_Output_DAs_Cros+16),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,52,(void *)(ReadMyCfg.Analog_Output_DAs_Cros+32),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        // ----------------- E: Analog Output -> DAC Cross

        // ----------------- S: Analog Output -> ADC DC Main
        EEPROM1_Flash0_Read(1000,53,(void *)(ReadMyCfg.Analog_Output_ADs_DC_Main+ 0),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,54,(void *)(ReadMyCfg.Analog_Output_ADs_DC_Main+16),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        EEPROM1_Flash0_Read(1000,55,(void *)(ReadMyCfg.Analog_Output_ADs_DC_Main+32),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0); //------
        // ----------------- E: Analog Output -> ADC DC Main

        // ----------------- S: Analog Output -> ADC DC Cross
        EEPROM1_Flash0_Read(1000,48,(void *)(ReadMyCfg.Analog_Output_ADs_DC_Cros+24),MODE_32_BIT, 8, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        EEPROM1_Flash0_Read(1000,49,(void *)(ReadMyCfg.Analog_Output_ADs_DC_Cros+32),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        // ----------------- E: Analog Output -> ADC DC Cross

        // ----------------- S: Analog Output -> ADC AC Main
        EEPROM1_Flash0_Read(1000,59,(void *)(ReadMyCfg.Analog_Output_ADs_AC_Main+0),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        EEPROM1_Flash0_Read(1000,60,(void *)(ReadMyCfg.Analog_Output_ADs_AC_Main+16),MODE_32_BIT,8, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        // ----------------- E: Analog Output -> ADC AC Main

        // ----------------- S: Analog Output -> ADC AC Cross
        EEPROM1_Flash0_Read(1000,61,(void *)(ReadMyCfg.Analog_Output_ADs_AC_Cros+0),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        EEPROM1_Flash0_Read(1000,62,(void *)(ReadMyCfg.Analog_Output_ADs_AC_Cros+16),MODE_32_BIT,8, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        // ----------------- E: Analog Output -> ADC AC Cross

        // ----------------- S: Binary Input -> Wet500
        EEPROM1_Flash0_Read(1000,64,(void *)(ReadMyCfg.Binary_Input+99),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        EEPROM1_Flash0_Read(1000,65,(void *)(ReadMyCfg.Binary_Input+115),MODE_32_BIT,11, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        // ----------------- E: Binary Input -> Wet500

        // ----------------- S: Binary Output
        EEPROM1_Flash0_Read(1000,56,(void *)(ReadMyCfg.BinaryOutput+ 0),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        EEPROM1_Flash0_Read(1000,57,(void *)(ReadMyCfg.BinaryOutput+16),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        // ----------------- E: Binary Output

        // ----------------- S: OptoHall
        EEPROM1_Flash0_Read(1000,58,(void *)(ReadMyCfg.Opto_Hall_Calibration),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        // ----------------- E: OptoHall

        // ----------------- S: Resistors_Calibration
        EEPROM1_Flash0_Read(1000,66,(void *)(ReadMyCfg.Resistors_Calibration+ 0),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        EEPROM1_Flash0_Read(1000,67,(void *)(ReadMyCfg.Resistors_Calibration+16),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        EEPROM1_Flash0_Read(1000,68,(void *)(ReadMyCfg.Resistors_Calibration+32),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        EEPROM1_Flash0_Read(1000,69,(void *)(ReadMyCfg.Resistors_Calibration+48),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        EEPROM1_Flash0_Read(1000,70,(void *)(ReadMyCfg.Resistors_Calibration+64),MODE_32_BIT,4, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        // ----------------- E: Resistors_Calibration

        // ----------------- S: LEDs_Calibration
        EEPROM1_Flash0_Read(1000,71,(void *)(ReadMyCfg.LEDs_Calibration+0),MODE_8_BIT,6, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        // ----------------- E: LEDs_Calibration

        // ----------------- S: Shunt
        EEPROM1_Flash0_Read(1000,72,(void *)(ReadMyCfg.Analog_Output_Shunt+0),MODE_32_BIT,12, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        // ----------------- E: Shunt

        // ----------------- S: Time_VA1_With_GPS
        EEPROM1_Flash0_Read(1000,73,(void *)(ReadMyCfg.Calibrate_Time_VA1_With_GPS+0),MODE_32_BIT,1, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        // ----------------- E: Time_VA1_With_GPS

        // ----------------- S: ExclusionSerial
        EEPROM1_Flash0_Read(1000,74,(void *)(ReadMyCfg.ExclusionSerial+0),MODE_32_BIT,16, 1-MMC_Flash_FlashOk1_FlashNotOk0);
        // ----------------- E: ExclusionSerial

        if(IsFRA){//-----EEProm FRA Read

            int countPart = 6;
            int offset = 31;
            for(int i=0; i<FRA_Number_Of_Gain; i++){
                offset = 31+(i*countPart);
                for(int j=0; j<countPart; j++){
                    if (j==countPart-1)
                        EEPROM1_Flash0_Read(1000,offset+j,(void *)(ReadMyCfg.AV_Freq_Gain_Calibration+(i*FRA_Number_Of_Frequncy+j*8)),MODE_64_BIT,4, 1-MMC_Flash_FlashOk1_FlashNotOk0);
                    else
                        EEPROM1_Flash0_Read(1000,offset+j,(void *)(ReadMyCfg.AV_Freq_Gain_Calibration+(i*FRA_Number_Of_Frequncy+j*8)),MODE_64_BIT,8, 1-MMC_Flash_FlashOk1_FlashNotOk0);
                }
            }
            for(int i=0; i<FRA_Number_Of_Gain; i++){
                offset = 31+FRA_Number_Of_Gain*countPart+(i*countPart);
                for(int j=0; j<countPart; j++){
                    if (j==countPart-1)
                        EEPROM1_Flash0_Read(1000,offset+j,(void *)(ReadMyCfg.Phi_Freq_Gain_Calibration+(i*FRA_Number_Of_Frequncy+j*8)),MODE_64_BIT,4, 1-MMC_Flash_FlashOk1_FlashNotOk0);
                    else
                        EEPROM1_Flash0_Read(1000,offset+j,(void *)(ReadMyCfg.Phi_Freq_Gain_Calibration+(i*FRA_Number_Of_Frequncy+j*8)),MODE_64_BIT,8, 1-MMC_Flash_FlashOk1_FlashNotOk0);
                }
            }

            int32_t gain = 0;
            int32_t freq = 0;
            for(int i=0;i<FRA_Number_Of_Gain*FRA_Number_Of_Frequncy;i++){
                ReadMyCfg.AV_Phi_Freq_Gain_Calibration_FRA[gain][freq][__AV] = ReadMyCfg.AV_Freq_Gain_Calibration[i];
                ReadMyCfg.AV_Phi_Freq_Gain_Calibration_FRA[gain][freq][__Phi] = ReadMyCfg.Phi_Freq_Gain_Calibration[i];

                freq = (freq + 1) % FRA_Number_Of_Frequncy;
                if (freq == 0) gain++;
            }
        }
        ReadMyCfg.Calibrate_Time_VA1_With_GPS=0;

        if (Main_Version <= 1){
            // ----------------- S: Analog Output -> ADC DC Main
            ReadMyCfg.Analog_Output_ADs_DC_Main[1+4* 0]=60000; ReadMyCfg.Analog_Output_ADs_DC_Main[3+4* 0]=-60000;
            ReadMyCfg.Analog_Output_ADs_DC_Main[1+4* 1]=60000; ReadMyCfg.Analog_Output_ADs_DC_Main[3+4* 1]=-60000;
            ReadMyCfg.Analog_Output_ADs_DC_Main[1+4* 2]=60000; ReadMyCfg.Analog_Output_ADs_DC_Main[3+4* 2]=-60000;
            ReadMyCfg.Analog_Output_ADs_DC_Main[1+4* 3]=60000; ReadMyCfg.Analog_Output_ADs_DC_Main[3+4* 3]= 10000;
            ReadMyCfg.Analog_Output_ADs_DC_Main[1+4* 4]=60000; ReadMyCfg.Analog_Output_ADs_DC_Main[3+4* 4]=-60000;
            ReadMyCfg.Analog_Output_ADs_DC_Main[1+4* 5]=60000; ReadMyCfg.Analog_Output_ADs_DC_Main[3+4* 5]=-60000;
            ReadMyCfg.Analog_Output_ADs_DC_Main[1+4* 6]= 5000; ReadMyCfg.Analog_Output_ADs_DC_Main[3+4* 6]= -5000;
            ReadMyCfg.Analog_Output_ADs_DC_Main[1+4* 7]= 5000; ReadMyCfg.Analog_Output_ADs_DC_Main[3+4* 7]= -5000;
            ReadMyCfg.Analog_Output_ADs_DC_Main[1+4* 8]= 5000; ReadMyCfg.Analog_Output_ADs_DC_Main[3+4* 8]= -5000;
            ReadMyCfg.Analog_Output_ADs_DC_Main[1+4* 9]= 5000; ReadMyCfg.Analog_Output_ADs_DC_Main[3+4* 9]= -5000;
            ReadMyCfg.Analog_Output_ADs_DC_Main[1+4*10]= 5000; ReadMyCfg.Analog_Output_ADs_DC_Main[3+4*10]= -5000;
            ReadMyCfg.Analog_Output_ADs_DC_Main[1+4*11]= 5000; ReadMyCfg.Analog_Output_ADs_DC_Main[3+4*11]= -5000;
            // ----------------- E: Analog Output -> ADC DC Main
        }
        else{
            Set_Main_IP(LED_TotalTime_SV62, (Main_Version>=9?((ReadMyCfg.LEDs_Calibration[4]<<0)+(ReadMyCfg.LEDs_Calibration[5]<<8)+(0<<16)):0));
            Set_Main_IP(LED_TotalTime_SV63, (Main_Version>=9?(ReadMyCfg.LEDs_Calibration[0]+(ReadMyCfg.LEDs_Calibration[1]<<8)+(ReadMyCfg.LEDs_Calibration[2]<<16)+(ReadMyCfg.LEDs_Calibration[3]<<24)):(64+(16<<8)+(48<<16)+(0<<24)+(0<<27)+(0<<29))));
        }
    }
    void EEPROMWriteConfig(WriteMode write_Mode, uint8_t doReset){
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("\r\n\r\n*****Bayad Write Bekonam Vaaaay: Mode: %d       Reset: %d\r\n", write_Mode, doReset); Delay_Xil_Printf;}

    	if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyIPConfigWithSerial || write_Mode==WriteMode_Serial){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_Serial\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000, 0, (void *)&(ReadMyCfg.Serial), MODE_8_BIT, 4);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_ClockCalibration){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_ClockCalibration\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000, 1, (void *)&(ReadMyCfg.ClockCalibration), MODE_8_BIT, 4);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyIPConfigWithoutSerial || write_Mode==WriteMode_OnlyIPConfigWithSerial || write_Mode==WriteMode_IP){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_IP\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000, 2, (void *)ReadMyCfg.IPConfig, MODE_8_BIT, 16);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyIPConfigWithoutSerial || write_Mode==WriteMode_OnlyIPConfigWithSerial || write_Mode==WriteMode_Port){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_Port\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000, 3, (void *)&(ReadMyCfg.Port), MODE_8_BIT, 2);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyIPConfigWithoutSerial || write_Mode==WriteMode_OnlyIPConfigWithSerial || write_Mode==WriteMode_MinVersion){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_MinVersion\r\n"); Delay_Xil_Printf;}
            if(ReadMyCfg.MinVersion!=0)
                EEPROM1_Flash0_Write(1000, 18, (void *)&(ReadMyCfg.MinVersion), MODE_32_BIT, 1);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyIPConfigWithoutSerial || write_Mode==WriteMode_OnlyIPConfigWithSerial || write_Mode==WriteMode_MAC){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_MAC\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,19,(void *)&(ReadMyCfg.MAC), MODE_8_BIT, 6);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_Analog_Output_DAs_Main){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_Analog_Output_DAs_Main\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,31,(void *)(ReadMyCfg.Analog_Output_DAs_Main+0) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,32,(void *)(ReadMyCfg.Analog_Output_DAs_Main+16), MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,33,(void *)(ReadMyCfg.Analog_Output_DAs_Main+32), MODE_32_BIT,16);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_Analog_Output_ADs_Cross){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_Analog_Output_ADs_Cross\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,34,(void *)(ReadMyCfg.Analog_Output_ADs_DC_Cros+0) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,35,(void *)(ReadMyCfg.Analog_Output_ADs_DC_Cros+16), MODE_32_BIT,8);
            EEPROM1_Flash0_Write(1000,48,(void *)(ReadMyCfg.Analog_Output_ADs_DC_Cros+24), MODE_32_BIT,8);
            EEPROM1_Flash0_Write(1000,49,(void *)(ReadMyCfg.Analog_Output_ADs_DC_Cros+32), MODE_32_BIT,16);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_Analog_Output_DAs_Cross){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_Analog_Output_DAs_Cross\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,50,(void *)(ReadMyCfg.Analog_Output_DAs_Cros+0) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,51,(void *)(ReadMyCfg.Analog_Output_DAs_Cros+16), MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,52,(void *)(ReadMyCfg.Analog_Output_DAs_Cros+32), MODE_32_BIT,16);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_Analog_Output_ADs_Main){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_Analog_Output_ADs_Main\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,53,(void *)(ReadMyCfg.Analog_Output_ADs_DC_Main+0) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,54,(void *)(ReadMyCfg.Analog_Output_ADs_DC_Main+16), MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,55,(void *)(ReadMyCfg.Analog_Output_ADs_DC_Main+32), MODE_32_BIT,16);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_Binary_Input){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_Binary_Input\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,36,(void *)(ReadMyCfg.Binary_Input+0)  , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,37,(void *)(ReadMyCfg.Binary_Input+16) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,38,(void *)(ReadMyCfg.Binary_Input+32) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,39,(void *)(ReadMyCfg.Binary_Input+48) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,40,(void *)(ReadMyCfg.Binary_Input+64) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,41,(void *)(ReadMyCfg.Binary_Input+80) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,42,(void *)(ReadMyCfg.Binary_Input+96) , MODE_32_BIT,3);
            EEPROM1_Flash0_Write(1000,64,(void *)(ReadMyCfg.Binary_Input+99) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,65,(void *)(ReadMyCfg.Binary_Input+115), MODE_32_BIT,11);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_Analog_Input){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_Analog_Input\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,43,(void *)(ReadMyCfg.Analog_Input+0) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,44,(void *)(ReadMyCfg.Analog_Input+16), MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,45,(void *)(ReadMyCfg.Analog_Input+32), MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,46,(void *)(ReadMyCfg.Analog_Input+48), MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,47,(void *)(ReadMyCfg.Analog_Input+64), MODE_32_BIT,8);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_Binary_Output){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_Binary_Output\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,56,(void *)(ReadMyCfg.BinaryOutput+0) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,57,(void *)(ReadMyCfg.BinaryOutput+16), MODE_32_BIT,16);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_Opto_Hall){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_Opto_Hall\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,58,(void *)(ReadMyCfg.Opto_Hall_Calibration), MODE_32_BIT,16);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_Analog_Output_ADs_AC_Main){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_Analog_Output_ADs_AC_Main\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,59,(void *)(ReadMyCfg.Analog_Output_ADs_AC_Main+0) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,60,(void *)(ReadMyCfg.Analog_Output_ADs_AC_Main+16), MODE_32_BIT,8);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_Analog_Output_ADs_AC_Cross){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_Analog_Output_ADs_AC_Cross\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,61,(void *)(ReadMyCfg.Analog_Output_ADs_AC_Cros+0) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,62,(void *)(ReadMyCfg.Analog_Output_ADs_AC_Cros+16), MODE_32_BIT,8);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_ResistorsCalibration){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_ResistorsCalibration\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,66,(void *)(ReadMyCfg.Resistors_Calibration+0) , MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,67,(void *)(ReadMyCfg.Resistors_Calibration+16), MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,68,(void *)(ReadMyCfg.Resistors_Calibration+32), MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,69,(void *)(ReadMyCfg.Resistors_Calibration+48), MODE_32_BIT,16);
            EEPROM1_Flash0_Write(1000,70,(void *)(ReadMyCfg.Resistors_Calibration+64), MODE_32_BIT,4);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_LEDsCalibration){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_LEDsCalibration\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,71,(void *)(ReadMyCfg.LEDs_Calibration), MODE_8_BIT,6);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_Analog_Output_Shunt){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_Analog_Output_Shunt\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,72,(void *)(ReadMyCfg.Analog_Output_Shunt), MODE_32_BIT,12);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_Calibrate_Time_VA1_With_GPS){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_Calibrate_Time_VA1_With_GPS\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,73,(void *)(ReadMyCfg.Calibrate_Time_VA1_With_GPS), MODE_32_BIT,1);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_ExclusionSerial){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_ExclusionSerial\r\n"); Delay_Xil_Printf;}
            EEPROM1_Flash0_Write(1000,74,(void *)(ReadMyCfg.ExclusionSerial), MODE_32_BIT,16);
        }
        if(write_Mode==WriteMode_All || write_Mode==WriteMode_OnlyCalibration || write_Mode==WriteMode_FRA){
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("WriteMode_FRA\r\n"); Delay_Xil_Printf;}
            if(IsFRA){
                int countPart = 6;
                int offset = 31;
                for(int i=0; i<FRA_Number_Of_Gain; i++){
                    offset = 31+(i*countPart);
                    for(int j=0; j<countPart; j++){
                        if (j==countPart-1)
                            EEPROM1_Flash0_Write(1000,offset+j,(void *)(ReadMyCfg.AV_Freq_Gain_Calibration+(i*FRA_Number_Of_Frequncy+j*8)), MODE_64_BIT,4);
                        else
                            EEPROM1_Flash0_Write(1000,offset+j,(void *)(ReadMyCfg.AV_Freq_Gain_Calibration+(i*FRA_Number_Of_Frequncy+j*8)), MODE_64_BIT,8);
                    }
                }
                for(int i=0; i<FRA_Number_Of_Gain; i++){
                    offset = 31+FRA_Number_Of_Gain*countPart+(i*countPart);
                    for(int j=0; j<countPart; j++){
                        if (j==countPart-1)
                            EEPROM1_Flash0_Write(1000,offset+j,(void *)(ReadMyCfg.Phi_Freq_Gain_Calibration+(i*FRA_Number_Of_Frequncy+j*8)), MODE_64_BIT,4);
                        else
                            EEPROM1_Flash0_Write(1000,offset+j,(void *)(ReadMyCfg.Phi_Freq_Gain_Calibration+(i*FRA_Number_Of_Frequncy+j*8)), MODE_64_BIT,8);
                    }
                }
            }
        }
        if(doReset)
            NVIC_SystemReset();
    }
#endif  //----------------------   E: Calibration
#if(1)  //----------------------   S: Interrupt
    void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority){
            if (priority >=3){
                prio = (priority+1)*8;
            }else{
                prio = (priority)*8;
            }
            switch (IRQn){
                case TIMER0_IRQn:
                    XScuGic_SetPriorityTriggerType(&IntcInstancePtr, XPAR_FABRIC_TESTER_HP_0_INTERRUPT_12_5us_VEC_ID, prio, 0x3);
                    break;
                case TIMER2_IRQn:
                    XScuGic_SetPriorityTriggerType(&IntcInstancePtr,XPAR_XTTCPS_2_INTR,prio,1);
                    break;
                case TIMER3_IRQn:
                    break;
                case GPIO_IRQn:
                    break;
                case ENET_IRQn:
                    break;
                case UART0_IRQn:
                    XScuGic_SetPriorityTriggerType(&IntcInstancePtr, XPS_UART1_INT_ID, prio, 0x3);
                    break;
                case UART2_IRQn:
                    XScuGic_SetPriorityTriggerType(&IntcInstancePtr, XPS_UART0_INT_ID, prio, 0x3);
                    break;
                case MCI_IRQn:
                    break;
                case DMA_IRQn:
                    break;
                case SysTick_IRQn:
                    break;
                case I2C1_IRQn:
                    break;
                default:
                    break;
            }
    }
    void NVIC_SystemReset(void){
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("@@@@@@@@@ Zynq System Reset_1\n"); Delay_Xil_Printf;}
        usleep(10000);
        Xil_Out32(XPAR_XSLCR_0_BASEADDR + SLCR_UNLOCK_ADDRESS,SLCR_UNLOCK_KEY);
        Xil_Out32(XPAR_XSLCR_0_BASEADDR + SLCR_SYSTEM_RESET,0x01);
    }
    void NVIC_Init(){
            IntcConfig = XScuGic_LookupConfig(XPAR_SCUGIC_SINGLE_DEVICE_ID);
            XScuGic_CfgInitialize(&IntcInstancePtr, IntcConfig,    IntcConfig->CpuBaseAddress);
            XScuGic_CPUWriteReg(&IntcInstancePtr, XSCUGIC_BIN_PT_OFFSET, 0x03);
            Xil_ExceptionInit();
            Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_IRQ_INT, (Xil_ExceptionHandler) XScuGic_DeviceInterruptHandler, (void *)XPAR_SCUGIC_SINGLE_DEVICE_ID);
//            Xil_ExceptionEnable();
    }
    void NVIC_EnableIRQ(IRQn_Type IRQn){
        if(IRQn == TIMER0_IRQn){
        #if(This_Is_Core1)
            int INT_61_62_63_From_IpCore=Xil_In32(0xF8F0183C);
            Xil_Out32(0xF8F0183C,(uint32_t)((INT_61_62_63_From_IpCore&0xFCFCFCFF)|0x2020200));
            XScuGic_Connect(&IntcInstancePtr, XPAR_FABRIC_TESTER_HP_0_INTERRUPT_12_5us_VEC_ID, (Xil_ExceptionHandler)TIMER0_IRQHandler, (void *)0);
            XScuGic_Enable(&IntcInstancePtr, XPAR_FABRIC_TESTER_HP_0_INTERRUPT_12_5us_VEC_ID);
            Xil_ExceptionEnable();
        }
        else if(IRQn == TIMER2_IRQn){
            int INT_44_TTC0=Xil_In32(0xF8F0182C);
            Xil_Out32(0xF8F0182C,(uint32_t)((INT_44_TTC0&0xFFFFFFFC)|0x2));
            XScuGic_Connect(&IntcInstancePtr, XPAR_XTTCPS_2_INTR, (Xil_ExceptionHandler)TIMER2_IRQHandler, (void *)TTC2);
            XScuGic_Enable(&IntcInstancePtr, XPAR_XTTCPS_2_INTR);
            XTtcPs_EnableInterrupts(TTC2, XTTCPS_IXR_INTERVAL_MASK);
        }
        else if(IRQn == UART2_IRQn){
            XScuGic_Connect(&IntcInstancePtr, XPS_UART0_INT_ID, (Xil_ExceptionHandler) XUartPs_InterruptHandler, (void *)&Uart_PS);
            int INT_59_UART0=Xil_In32(0xF8F01838);
            Xil_Out32(0xF8F01838,(uint32_t)((INT_59_UART0&0xFCFFFFFF)|0x2000000));

            XScuGic_Enable(&IntcInstancePtr, XPS_UART0_INT_ID);
            Xil_ExceptionEnable();

            XUartPs_SetHandler(&Uart_PS, (XUartPs_Handler)UART2_IRQHandler, &Uart_PS);

            IntrMask =
                XUARTPS_IXR_TOUT | XUARTPS_IXR_PARITY | XUARTPS_IXR_FRAMING |
                XUARTPS_IXR_OVER | XUARTPS_IXR_TXEMPTY | XUARTPS_IXR_RXFULL |
                XUARTPS_IXR_RXOVR;

            XUartPs_SetInterruptMask(&Uart_PS, IntrMask);
            XUartPs_SetBaudRate(&Uart_PS, 9600);


            XUartPs_SetOperMode(&Uart_PS, XUARTPS_OPER_MODE_NORMAL);


            XUartPs_SetRecvTimeout(&Uart_PS, 8);

            XUartPs_Recv(&Uart_PS, &UART_RecvBuffer, 1);

        #endif
        }
        else if(IRQn == UART0_IRQn){
            XScuGic_Connect(&IntcInstancePtr, XPS_UART1_INT_ID, (Xil_ExceptionHandler) XUartPs_InterruptHandler, (void *)&Uart_PS0);
            int INT_82_UART1=Xil_In32(0xF8F01850);
            Xil_Out32(0xF8F01850,(uint32_t)((INT_82_UART1&0xFFFCFFFF)|(This_Is_Core1?0x20000:0x10000)));
            XScuGic_Enable(&IntcInstancePtr, XPS_UART1_INT_ID);
            Xil_ExceptionEnable();
            XUartPs_SetHandler(&Uart_PS0, (XUartPs_Handler)UART1_IRQHandler, &Uart_PS0);
            IntrMask = XUARTPS_IXR_TOUT | XUARTPS_IXR_PARITY | XUARTPS_IXR_FRAMING | XUARTPS_IXR_OVER | XUARTPS_IXR_TXEMPTY | XUARTPS_IXR_RXFULL | XUARTPS_IXR_RXOVR;
            XUartPs_SetInterruptMask(&Uart_PS0, IntrMask);
            XUartPs_SetFifoThreshold(&Uart_PS0, 2);
            XUartPs_SetOperMode(&Uart_PS0, XUARTPS_OPER_MODE_NORMAL);
            XUartPs_SetRecvTimeout(&Uart_PS0, 8);
            XUartPs_Recv(&Uart_PS0, &UART_RecvBuffer, 1);
        }
    }
#endif  //----------------------   E: Interrupt
#if(1)  //----------------------   S: USB
    void USB_Init(){
        USB_Config = XUsbPs_LookupConfig(XPAR_PS7_USB_0_DEVICE_ID);
        XUsbPs_CfgInitialize(&USB_PS, USB_Config, USB_Config->BaseAddress);
    }
#endif  //----------------------   E: USB
#if(1)  //----------------------   S: UART
    void UART_Init(UART_ID_Type UartID, XUartPsFormat *UART_ConfigStruct){
        if(UartID == UART_0){
            if(UART0_Init_Var != 100){
                Uart_Config0 = XUartPs_LookupConfig(XPAR_PS7_UART_1_DEVICE_ID);
                XUartPs_CfgInitialize(&Uart_PS0, Uart_Config0, Uart_Config0->BaseAddress);
                XUartPs_SetDataFormat(&Uart_PS0 , UART_ConfigStruct);
                UART0_Init_Var = 100;
            }
        }
        if(UartID == UART_2){
            if(UART2_Init_Var != 100){
                Uart_Config = XUartPs_LookupConfig(XPAR_XUARTPS_0_DEVICE_ID);
                XUartPs_CfgInitialize(&Uart_PS, Uart_Config, Uart_Config->BaseAddress);
                UART2_Init_Var = 100;
            }
        }
    }
    void UART1_IRQHandler (void *CallBackRef, u32 Event, unsigned int EventData){
        Xil_EnableNestedInterrupts();
        uint8_t senduart[8];
        int32_t headerCount=0;

        if (Event == XUARTPS_EVENT_RECV_DATA){
            Recive_Serial_Data_Len_In_Partial_Now=XUartPs_Recv(&Uart_PS0, tempReceivePacket+Recive_Serial_Data_Len_In_Partial, 1);

            if(Recive_Serial_Data_Len_In_Partial_Now!=0){
                Counter_Send_and_Recive_Serial_For_Disconnect=0;
                Recive_Serial_Data_Len_In_Partial+=Recive_Serial_Data_Len_In_Partial_Now;

                
                if (Recive_Serial_Data_Len_In_Partial > 7){
                    if(tempReceivePacket[0] == 255 && tempReceivePacket[1] == 255){
                        if(tempReceivePacket[2] == 255 && tempReceivePacket[3] == 0){
                            if(Recive_Serial_Data_Len_In_Partial==(*(uint16_t *)(tempReceivePacket+4)))
                                headerCount=6;
                            Flag_255_First_Bytes=0;
                        }
                        else if(tempReceivePacket[2] == 0){
                            if(Recive_Serial_Data_Len_In_Partial==(*(uint16_t *)(tempReceivePacket+3))-1)
                                headerCount=5;
                            Flag_255_First_Bytes=1;
                        }
                    }
                }
                if(headerCount!= 0){
                    memcpy(receiveLAN, tempReceivePacket+headerCount, Recive_Serial_Data_Len_In_Partial-headerCount);
                    NumberOfByteRecieve = Recive_Serial_Data_Len_In_Partial-headerCount;
                    Recive_Serial_Data_Len_In_Partial=0;
                    Flag_Send_and_Recive_Serial=1;
                    Flag_255_First_Bytes=0;
                }
                else if(Recive_Serial_Data_Len_In_Partial % (256-(Flag_255_First_Bytes==1?1:0))==0){
                    Flag_255_First_Bytes=2;
                    senduart[0]=0xff;
                    senduart[1]=0xff;
                    *(uint16_t *)(senduart+2)=8;
                    senduart[4]=0;
                    senduart[5]=0;
                    senduart[6]=0;
                    senduart[7]=0;
                    XUartPs_Send(&Uart_PS0,senduart,8);
                }
            }
        }
        Xil_DisableNestedInterrupts();
    }
    void UART_Init_Parameters(UART_ID_Type UartID, uint32_t BaudRate, uint8_t FORMAT_BITS, uint8_t FORMAT_PARITY, uint8_t FORMAT_STOP_BIT){
        Glb_UARTConfigStruct.BaudRate = BaudRate;
        Glb_UARTConfigStruct.DataBits = FORMAT_BITS;
        Glb_UARTConfigStruct.Parity = FORMAT_PARITY;
        Glb_UARTConfigStruct.StopBits = FORMAT_STOP_BIT;
        UART_Init(UartID, &Glb_UARTConfigStruct);
        if(UartID == UART_0){
            NVIC_SetPriority(UART0_IRQn, 5);
            NVIC_EnableIRQ(UART0_IRQn);
        }
        if(UartID == UART_2){
            NVIC_SetPriority(UART2_IRQn, 5);
            NVIC_EnableIRQ(UART2_IRQn);
        }
    }
    void Couter_Serial_Disconnect(void){
        Counter_For_Finding_Problem++;
        if(Counter_Send_and_Recive_Serial_For_Disconnect>=0)
            Counter_Send_and_Recive_Serial_For_Disconnect++;
        if(Counter_Send_and_Recive_Serial_For_Disconnect>4500){
            Flag_Send_and_Recive_Serial=0;
            Counter_Send_and_Recive_Serial_For_Disconnect=-1;
            Recive_Serial_Data_Len_In_Partial=0;
            Recive_Serial_Data_Len_In_Partial_Now=0;
            Flag_255_First_Bytes=0;
        }
    }
#endif  //----------------------   E: UART
#if(1)  //----------------------   S: Timer
    void TIM_Cmd(uint8_t TImx, FunctionalState NewState){
        if(TImx == LPC_TIM0){
            if(NewState == ENABLE)
                Set_Main_IP(Timer0_Start_SV12, 1);
            else
                Set_Main_IP(Timer0_Start_SV12, 0);
        }
        else if(TImx == LPC_TIM1 ){
            if(NewState == ENABLE)
                XTtcPs_Start(TTC1);
            else
                XTtcPs_Stop(TTC1);
        }
        else if(TImx == LPC_TIM2){
            if(NewState == ENABLE)
                XTtcPs_Start(TTC2);
            else
                XTtcPs_Stop(TTC2);
        }
        else if(TImx == LPC_TIM3){
            if(NewState == ENABLE)
                XTtcPs_Start(TTC3);
            else
                XTtcPs_Stop(TTC3);
        }
    }
    void TIM_Init(uint8_t TImx){
            if(TImx == LPC_TIM0){
            }
            else if(TImx == LPC_TIM1){
                TimerSetup.Options = 0;
                TTC1 = &(TtcPsInst[XPAR_XTTCPS_1_DEVICE_ID]);
                Config = XTtcPs_LookupConfig(XPAR_XTTCPS_1_DEVICE_ID);
                XTtcPs_CfgInitialize(TTC1, Config, Config->BaseAddress);
                XTtcPs_SetOptions(TTC1, TimerSetup.Options);
                XTtcPs_SetInterval(TTC1, 1);
                XTtcPs_SetPrescaler(TTC1, 16);
            }
            else if(TImx == LPC_TIM2){
                TimerSetup.Options |= (XTTCPS_OPTION_INTERVAL_MODE |   XTTCPS_OPTION_MATCH_MODE);
                TTC2 = &(TtcPsInst[XPAR_XTTCPS_2_DEVICE_ID]);
                Config = XTtcPs_LookupConfig(XPAR_XTTCPS_2_DEVICE_ID);
                XTtcPs_CfgInitialize(TTC2, Config, Config->BaseAddress);
                XTtcPs_SetOptions(TTC2, TimerSetup.Options);
                XTtcPs_SetInterval(TTC2, 1000);
                XTtcPs_SetPrescaler(TTC2, 16);
            }
            else if(TImx == LPC_TIM3){

            }
    }
    void TIM_ResetCounter(uint8_t TImx){
            if(TImx == LPC_TIM0){

            }
            else if(TImx == LPC_TIM1){
                XTtcPs_ResetCounterValue(TTC1);
            }
            else if(TImx == LPC_TIM2){
                XTtcPs_ResetCounterValue(TTC2);
            }
            else if(TImx == LPC_TIM3){
            }
    }

#endif  //----------------------   E: Timer
#if(1)  //----------------------   S: LAN
    uint8_t tcp_get_state(uint8_t socket_tcp){
        if(Main_Version>1 || This_Is_SSBL_Destroy!=0){
            if(LAN_Connected==1)
                return 10;
        }
        else{
            if(Glb_common_PS0_PS1->Connected==1)
                return 10;
        }
        return 0;
    }
    int send_data (uint8_t *data, u16 length) {
        int status;
        uint8_t sendDataTemp[SendLan_Len];
        Send_1s_For_Stay_Connect=0;
        if(Flag_Send_and_Recive_Serial==1 || (Main_Version>1 || This_Is_SSBL_Destroy!=0)){
            if(Flag_Send_and_Recive_Serial==1){
                if(length<4)
                    length= 8;
                else
                    length+=4;
                sendDataTemp[0] = 0xFF;
                sendDataTemp[1] = 0xFF;
                *(uint16_t *)(sendDataTemp+2)=length;

                if(data[0]==4)
                    data[0]=4;
                for (int i = 4; i < length; i++)
                    sendDataTemp[i]=data[i - 4];

                int sendPacketSize     = 100;
                int numberOfSendPacket = (length / sendPacketSize) + (length % sendPacketSize != 0 ? 1 : 0);
                if (numberOfSendPacket > 1){
                    numberOfSendPacket = numberOfSendPacket+1;
                    numberOfSendPacket = numberOfSendPacket-1;
                }
                for (int offset = 0; offset < length; offset += sendPacketSize)
                {
                    int lengthToSendPacket = ((length - offset < sendPacketSize) ? length - offset : sendPacketSize);
                    usleep(10000);
                    XUartPs_Send(&Uart_PS0, sendDataTemp+offset, lengthToSendPacket);
                }
            }
            else{
                status = tcp_write(pcb, data, length,1);if( status!=ERR_OK) return 0;
            }
        }
        else{
            for (int i=0; i< length ; i++ )
                Glb_common_PS0_PS1->SendLan[i]= data[i];
            Glb_common_PS0_PS1->NumberOfByteSend=length;
        }
        return 1;
    }
    err_t recv_callback(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err){
        if (!p) {
            tcp_close(tpcb);
            tcp_recv(tpcb, NULL);
            return ERR_OK;
        }

        tcp_recved(tpcb, p->len);
        pcb=tpcb;

        for(int i=0; i<p->len; i++){
            receiveLAN[i]=((uint8_t *)p->payload)[i];
        }
        LAN_Counter_Disconnect=0;

        int num=p->len;
        pbuf_free(p);
        NumberOfByteRecieve=num;
        return ERR_OK;
    }
    err_t accept_callback(void *arg, struct tcp_pcb *newpcb, err_t err)
    {
        static int connection = 1;
        tcp_recv(newpcb, recv_callback);
        tcp_arg(newpcb, (void*)(UINTPTR)connection);
        connection++;

        return ERR_OK;
    }
    void Ethernet_Init(void){
        ip_addr_t ipaddr, netmask, gw;
         if(Main_Version>1 || This_Is_SSBL_Destroy!=0){
            Ethernet_VCC_SET;
            sleep(1);
            unsigned char mac_ethernet_address[] = {ReadMyCfg.MAC[0],ReadMyCfg.MAC[1],ReadMyCfg.MAC[2],ReadMyCfg.MAC[3],ReadMyCfg.MAC[4],ReadMyCfg.MAC[5]};
            echo_netif = &server_netif;
            lwip_init();
            xemac_add(echo_netif, &ipaddr, &netmask, &gw, mac_ethernet_address, XPAR_XEMACPS_1_BASEADDR);
            netif_set_default(echo_netif);
            netif_set_up(echo_netif);
            for(int i=0; i<12; i++){
                if(Flag_Send_and_Recive_Serial!=1) {xil_printf("IP[%d]: %d\r\n",i, ReadMyCfg.IPConfig[i]); Delay_Xil_Printf;}
            }
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("Port: %d\r\n", ReadMyCfg.Port); Delay_Xil_Printf;}
            for(int i=0; i<5; i++){
                if(Flag_Send_and_Recive_Serial!=1) {xil_printf("MAC[%d]: %d\r\n",i, ReadMyCfg.MAC[i]); Delay_Xil_Printf;}
            }

            IP4_ADDR(&(echo_netif->ip_addr),  ReadMyCfg.IPConfig[0], ReadMyCfg.IPConfig[1], ReadMyCfg.IPConfig[2],ReadMyCfg.IPConfig[3]);
            IP4_ADDR(&(echo_netif->gw), ReadMyCfg.IPConfig[4],ReadMyCfg.IPConfig[5],ReadMyCfg.IPConfig[6], ReadMyCfg.IPConfig[7]);
            IP4_ADDR(&(echo_netif->netmask),  ReadMyCfg.IPConfig[8],ReadMyCfg.IPConfig[9],ReadMyCfg.IPConfig[10], ReadMyCfg.IPConfig[11]);
            ipaddr.addr = echo_netif->ip_addr.addr;
            gw.addr = echo_netif->gw.addr;
            netmask.addr = echo_netif->netmask.addr;

            unsigned port = ReadMyCfg.Port;

            pcb = tcp_new_ip_type(IPADDR_TYPE_ANY);
            err = tcp_bind(pcb, IP_ANY_TYPE, port);
            tcp_arg(pcb, NULL);
            pcb = tcp_listen(pcb);
            tcp_accept(pcb, accept_callback);
        }
    }
    void timer_callback()
    {
        static int DetectEthLinkStatus = 0;
        static int odd = 1;
        static int ResetRxCntr = 0;
        if(Main_Version>1 || This_Is_SSBL_Destroy!=0){
            ResetRxCntr++;
            if (ResetRxCntr >= 400) {
                xemacpsif_resetrx_on_no_rxdata(echo_netif);
                ResetRxCntr = 0;
            }
            DetectEthLinkStatus++;
            TcpFastTmrFlag = 1;
            odd = !odd;
            if (odd) {
                TcpSlowTmrFlag = 1;
            }
            if (DetectEthLinkStatus == 4) {
                eth_link_detect(echo_netif);
                DetectEthLinkStatus = 0;
            }

            if (TcpFastTmrFlag) {
                tcp_fasttmr();
                TcpFastTmrFlag = 0;
            }
            if (TcpSlowTmrFlag) {
                tcp_slowtmr();
                TcpSlowTmrFlag = 0;
            }

            XEmacPs_IntrHandler((void *)xemacpsif_addr);
            xemacif_input(echo_netif);
            if(LAN_Counter_Disconnect >= 10000){
                LAN_Counter_Disconnect = 10000;
                LAN_Connected = 0;
            }
            else{
                LAN_Connected = 1;
            }
        }
    }
#endif  //----------------------   E: LAN
#if(1)  //----------------------   S: Emac
    void EMAC_WritePacketBuffer(EMAC_PACKETBUF_Type *pDataStruct){
        if(Main_Version>1 || This_Is_SSBL_Destroy!=0){
            struct pbuf *p;
            p = pbuf_alloc(PBUF_RAW, XEMACPS_MAX_FRAME_SIZE, PBUF_POOL);
            struct xemac_s *xemac = (struct xemac_s *)(echo_netif->state);
            xemacpsif_s *xemacpsif = (xemacpsif_s *)(xemac->state);


            for(int i=0; i<pDataStruct->ulDataLen_Number_Of_byte; i++)
                *(((uint8_t *)p->payload)+i)=pDataStruct->pbDataBuf[i];
            p->len=pDataStruct->ulDataLen_Number_Of_byte;
            emacps_sgsend(xemacpsif,p);
            DataPacket.ulDataLen_Number_Of_byte=0;
            pbuf_free(p);
        }
        else{
            for(int i=0; i<pDataStruct->ulDataLen_Number_Of_byte; i++)
                Glb_common_PS0_PS1->EmacDataSend[i]=pDataStruct->pbDataBuf[i];
            Glb_common_PS0_PS1->EmacDataLenSend=pDataStruct->ulDataLen_Number_Of_byte;
        }
    }
    void EMAC_printf (char *txtBuff, const char *format, ...){
        va_list arg;

        va_start (arg, format);
        vsprintf (txtBuff, format, arg);
        va_end (arg);

        uint8_t DSize = strlen(txtBuff);
        uint8_t __attribute__ ((aligned (4))) gTxBuf[(14 + 4 + DSize) + 0x10];
        EMAC_PACKETBUF_Type DataPacket;
        *(gTxBuf + 0) = 0xFF;
        *(gTxBuf + 1) = 0xFF;
        *(gTxBuf + 2) = 0xFF;
        *(gTxBuf + 3) = 0xFF;
        *(gTxBuf + 4) = 0xFF;
        *(gTxBuf + 5) = 0xFF;

        *(gTxBuf + 6)  = 0x11;
        *(gTxBuf + 7)  = 0x22;
        *(gTxBuf + 8)  = 0x33;
        *(gTxBuf + 9)  = 0x44;
        *(gTxBuf + 10) = 0x55;
        *(gTxBuf + 11) = 0x66;

        // Body Length
        *(gTxBuf + 12) = DSize & 0xFF;
        *(gTxBuf + 13) = (DSize >> 0x08) & 0xFF;

        // Text Size
        *(gTxBuf + 14) = DSize;

        memcpy(&gTxBuf[18], &txtBuff[0], DSize);

        *(uint32_t *)(gTxBuf + 14 + 4 + DSize) = crc32_bfr( gTxBuf, (14 + 4 + DSize) );

        DataPacket.pbDataBuf                = gTxBuf;
        DataPacket.ulDataLen_Number_Of_byte = (14 + 4 + DSize) + 4;

        EMAC_WritePacketBuffer(&DataPacket);
    }
    int8_t EmacIsRelease(void){
        if(Main_Version>1 || This_Is_SSBL_Destroy!=0)
            return    DataPacket.ulDataLen_Number_Of_byte==0;
        else
            return    Glb_common_PS0_PS1->EmacDataLenSend==0;

    }
    void crc32_init(uint32_t *pCRC)
    {
        *pCRC = 0xffffffff;
    }
    void crc32_add(uint32_t *pCRC, uint8_t val8)
    {
        uint32_t i, poly;
        uint32_t entry;
        uint32_t crc_in;
        uint32_t crc_out;

        crc_in = *pCRC;
        poly = 0xEDB88320L;
        entry = (crc_in ^ ((uint32_t) val8)) & 0xFF;
        for (i = 0; i < 8; i++)
        {
        if (entry & 1)
        entry = (entry >> 1) ^ poly;
        else
        entry >>= 1;
        }
        crc_out = ((crc_in>>8) & 0x00FFFFFF) ^ entry;
        *pCRC = crc_out;
        return;
    }
    void crc32_end(uint32_t *pCRC)
    {
        *pCRC ^= 0xffffffff;
    }
    uint32_t crc32_bfr(void *pBfr, uint32_t size)
    {
        uint32_t crc32;
        uint8_t  *pu8;

        crc32_init(&crc32);
        pu8 = (uint8_t *) pBfr;
        while (size-- != 0)
        {
        crc32_add(&crc32, *pu8);
        pu8++ ;
        }
        crc32_end(&crc32);
        return ( crc32 );
    }
    void SendIpAddress(){
        uint32_t crcValue;
        uint32_t BodyLength = TX_PACKET_SIZE - 14;
        int32_t counter = 0;
        uint8_t __attribute__ ((aligned (4))) gTxBuf[TX_PACKET_SIZE + 0x10];
        if(EmacIsRelease() == 1 && CanSendIpAdress==1){
            *(gTxBuf+counter) = 0xFF; counter++;
            *(gTxBuf+counter) = 0xFF; counter++;
            *(gTxBuf+counter) = 0xFF; counter++;
            *(gTxBuf+counter) = 0xFF; counter++;
            *(gTxBuf+counter) = 0xFF; counter++;
            *(gTxBuf+counter) = 0xFF; counter++;

            *(gTxBuf+counter) = 0x44; counter++;
            *(gTxBuf+counter) = 0x44; counter++;
            *(gTxBuf+counter) = 0x44; counter++;
            *(gTxBuf+counter) = 0x44; counter++;
            *(gTxBuf+counter) = 0x44; counter++;
            *(gTxBuf+counter) = 0x44; counter++;

            *(gTxBuf+counter) = BodyLength & 0xFF;           counter++;
            *(gTxBuf+counter) = (BodyLength >> 0x08) & 0xFF; counter++;

            *(gTxBuf+counter) = ReadMyCfg.IPConfig[0];  counter++;
            *(gTxBuf+counter) = ReadMyCfg.IPConfig[1];  counter++;
            *(gTxBuf+counter) = ReadMyCfg.IPConfig[2];  counter++;
            *(gTxBuf+counter) = ReadMyCfg.IPConfig[3];  counter++;

            *(gTxBuf+counter) = ReadMyCfg.IPConfig[8]; counter++;
            *(gTxBuf+counter) = ReadMyCfg.IPConfig[9]; counter++;
            *(gTxBuf+counter) = ReadMyCfg.IPConfig[10];counter++;
            *(gTxBuf+counter) = ReadMyCfg.IPConfig[11];counter++;

            *(gTxBuf+counter) = ReadMyCfg.IPConfig[4]; counter++;
            *(gTxBuf+counter) = ReadMyCfg.IPConfig[5]; counter++;
            *(gTxBuf+counter) = ReadMyCfg.IPConfig[6]; counter++;
            *(gTxBuf+counter) = ReadMyCfg.IPConfig[7]; counter++;

            *(gTxBuf+counter) = ReadMyCfg.IPConfig[12]; counter++;
            *(gTxBuf+counter) = ReadMyCfg.IPConfig[13]; counter++;
            *(gTxBuf+counter) = ReadMyCfg.IPConfig[14]; counter++;
            *(gTxBuf+counter) = ReadMyCfg.IPConfig[15]; counter++;

            *(gTxBuf+counter) = ReadMyCfg.Port>>0; counter++;
            *(gTxBuf+counter) = ReadMyCfg.Port>>8; counter++;

            *(gTxBuf+counter) = ReadMyCfg.MAC[0]; counter++;
            *(gTxBuf+counter) = ReadMyCfg.MAC[1]; counter++;
            *(gTxBuf+counter) = ReadMyCfg.MAC[2]; counter++;
            *(gTxBuf+counter) = ReadMyCfg.MAC[3]; counter++;
            *(gTxBuf+counter) = ReadMyCfg.MAC[4]; counter++;
            *(gTxBuf+counter) = ReadMyCfg.MAC[5]; counter++;

            *(gTxBuf+counter) = (tcp_get_state(socket_tcp)!=10)?0:1;  counter++;

            *(gTxBuf+counter) = ReadMyCfg.Serial;     counter++;
            *(gTxBuf+counter) = ReadMyCfg.Serial>>8;  counter++;
            *(gTxBuf+counter) = ReadMyCfg.Serial>>16; counter++;
            *(gTxBuf+counter) = ReadMyCfg.Serial>>24; counter++;

            crcValue = crc32_bfr( gTxBuf, TX_PACKET_SIZE );
            *(gTxBuf+TX_PACKET_SIZE) = (0xff & crcValue);
            *(gTxBuf+TX_PACKET_SIZE+1) = 0xff & (crcValue >> 8 );
            *(gTxBuf+TX_PACKET_SIZE+2) = 0xff & (crcValue >> 16);
            *(gTxBuf+TX_PACKET_SIZE+3) = 0xff & (crcValue >> 24);

#if(This_Is_SSBL)
            DataPacket.pbDataBuf=gTxBuf;
            DataPacket.ulDataLen_Number_Of_byte=4*(TX_PACKET_SIZE + 4);
            EMAC_WritePacketBuffer(&DataPacket);
#endif
#if(This_Is_Core1)
            Glb_Queue_Send_AvailableDevice.Front = (Glb_Queue_Send_AvailableDevice.Front + 1) % Maximum_Number_Of_Emac_Queue_ForSend;
            for(int i=0;i<4*(TX_PACKET_SIZE + 4);i++)
                Glb_Queue_Send_AvailableDevice.Packet[Glb_Queue_Send_AvailableDevice.Front].Data[i] = gTxBuf[i];
            Glb_Queue_Send_AvailableDevice.Packet[Glb_Queue_Send_AvailableDevice.Front].Length=4*(TX_PACKET_SIZE + 4);
#endif
        }
    }
    void ChangeIPConfigByGoos(uint8_t *dp, uint32_t count){
        uint32_t i      = 0;
        uint32_t SerialTargetDevice = 0;
        if(dp[count]==2){
            SerialTargetDevice=*(uint32_t *)(dp+count+1);
            SerialTargetDevice=Correct_Serial_Number_Specific(SerialTargetDevice);
            if (SerialTargetDevice == ReadMyCfg.Serial)
            {
                for(i=0;i<16;i++) ReadMyCfg.IPConfig[i] = dp[i+count+5];
                ReadMyCfg                  .Port        = *(uint16_t *)(dp+21+count);
                ReadMyCfg                  .Serial      = *(uint32_t *)(dp+23+count); Correct_Serial_Number();
                Correct_Serial_Number();

                for(i=0;i<6;i++) ReadMyCfg .MAC[i]      = dp[i+27+count];
                Flag_WriteMode_OnlyIPConfigWithoutSerial_For_Goose_Because_In_Goose_System_Reset=1;
            }
        }
    }
    void DoWorkForGoose(struct pbuf *p) {
        //Copy From xemacpsif.c line 170
        u8  *dp;
        uint32_t count=14;
        uint16_t length=0;
#if(This_Is_Core1)
        uint16_t dp12=0;
#endif
         if(Main_Version>1){
            dp=(u8 *)p->payload;
            length = p->len;
        }
        else{
            dp = Glb_common_PS0_PS1->EmacDataReciev;
            length = Glb_common_PS0_PS1->EmacDataLenReciev;
        }
        if(length>=32 && length<1000){
        ///////Apply These Condition To main.c of core1 (ETHERNET) line 141
            if(dp[6] == 0xAA && dp[7] == 0xEE){
                    if(dp[0] == 0xFF && dp[1] == 0xFF && dp[2] == 0xFF && dp[3] == 0xFF && dp[4] == 0xFF && dp[5] == 0xFF && dp[6] == 0xAA && dp[7] == 0xEE && dp[8] == 0x44 && dp[9] == 0x44 && dp[10] == 0x44 && dp[11] == 0x44){
                        ChangeIPConfigByGoos(dp, count);
                }
            }
            else if ((dp[16] == 0x88 && dp[17] == 0xb8)||(dp[12] == 0x88 && dp[13] == 0xb8)){
#if(This_Is_Core1)
                if(dp[12] == 0x88 && dp[13] == 0xb8){
                    dp12=1;
                }
                if(GooseData[0]!=0){
                    ChangeBinaryInputsByGoose(dp, length, dp12);
                }
#endif
            }
        }
    }
#endif  //----------------------   E: Emac
#if(1)  //----------------------   S: eMMC
    void read_from_MMC(uint8_t *Pdata, uint32_t blockNum, uint32_t numOfBlock) {
        if(MMC_Flash_MMCOk1_MMChNotOk0==1){
            DSTATUS stat;
            stat = disk_read(1, Pdata, blockNum, numOfBlock);
            if(stat != RES_OK)
                if(Flag_Send_and_Recive_Serial!=1) {xil_printf("Man Gir Kardam To Read Emmc\r\n"); Delay_Xil_Printf;}
        }
        else
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("Man Gir Kardam To Read Emmc Chon init kharabeh\r\n"); Delay_Xil_Printf;}
    }
    void Write_to_MMC(uint8_t *Pdata, uint32_t blockNum, uint32_t numOfBlock) {
        if(MMC_Flash_MMCOk1_MMChNotOk0==1){
            DSTATUS stat;
            stat = disk_write(1, Pdata, blockNum, numOfBlock);
            if(stat != RES_OK)
                if(Flag_Send_and_Recive_Serial!=1) {xil_printf("Man Gir Kardam To Write Emmc\r\n"); Delay_Xil_Printf;}
        }
        else
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("Man Gir Kardam To Write Emmc Chon init kharabeh\r\n"); Delay_Xil_Printf;}
    }
    // 0 : external SDIO (uSD, WiFi)
    // 1 : internal SDIO (eMMC)
    void Onboard_eMMC_Init(void) {
        DSTATUS stat;
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("\r\neMMC Initializing..."); Delay_Xil_Printf;}
        stat = disk_initialize(1);
        if (stat & STA_NOINIT) {             /* Check if the initialization succeeded */
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("Error\r\n"); Delay_Xil_Printf;}
            //while(1);            /* Failed to initialize due to no medium or hard error */
            MMC_Flash_MMCOk1_MMChNotOk0=0;
        }
        else
            MMC_Flash_MMCOk1_MMChNotOk0=1;
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("Done.\r\n"); Delay_Xil_Printf;}
    }
#endif  //----------------------   E: eMMC
#if(1)  //----------------------   S: Flash
    void FlashErase(XQspiPs *QspiPtr, u32 sector){
        u8 WriteEnableCmd = { WRITE_ENABLE_CMD };
        u8 ReadStatusCmd[] = { READ_STATUS_CMD, 0 };  /* must send 2 bytes */
        u8 FlashStatus[2];

        u32 Address = sector * SECTOR_SIZE;

        XQspiPs_PolledTransfer(&QspiInstance, &WriteEnableCmd, NULL, sizeof(WriteEnableCmd));


        if(FLASH_TYPE == SPANTION_TYPE)
            WriteBuffer[COMMAND_OFFSET]   = 0x17;
        else
            WriteBuffer[COMMAND_OFFSET]   = 0xC5;
        WriteBuffer[ADDRESS_1_OFFSET] = (u8)(Address >> 24);

        XQspiPs_PolledTransfer(&QspiInstance, WriteBuffer, NULL,2);
        while (1) {
            XQspiPs_PolledTransfer(&QspiInstance, ReadStatusCmd, FlashStatus,sizeof(ReadStatusCmd));
            if ((FlashStatus[1] & 0x01) == 0) {
                break;
            }
        }

        XQspiPs_PolledTransfer(QspiPtr, &WriteEnableCmd, NULL, sizeof(WriteEnableCmd));

        WriteBuffer[COMMAND_OFFSET]   = SEC_ERASE_CMD;
        WriteBuffer[ADDRESS_1_OFFSET] = (u8)(Address >> 16);
        WriteBuffer[ADDRESS_2_OFFSET] = (u8)(Address >> 8);
        WriteBuffer[ADDRESS_3_OFFSET] = (u8)(Address & 0xFF);
        XQspiPs_PolledTransfer(QspiPtr, WriteBuffer, NULL, SEC_ERASE_SIZE);
        while (1) {
            XQspiPs_PolledTransfer(QspiPtr, ReadStatusCmd, FlashStatus, sizeof(ReadStatusCmd));
            if ((FlashStatus[1] & 0x01) == 0) {
                break;
            }
        }
    }
    int FlashReadID(void)
    {
        int Status;
        WriteBuffer[COMMAND_OFFSET]   = READ_ID;
        WriteBuffer[ADDRESS_1_OFFSET] = 0x23;
        WriteBuffer[ADDRESS_2_OFFSET] = 0x08;
        WriteBuffer[ADDRESS_3_OFFSET] = 0x09;

        Status = XQspiPs_PolledTransfer(&QspiInstance, WriteBuffer, ReadBuffer, RD_ID_SIZE);
        return Status+(ReadBuffer[1]<<8)+ (ReadBuffer[2]<<16)+(ReadBuffer[3]<<24);
    }
    void FlashQuadEnable(XQspiPs *QspiPtr)
    {
        u8 WriteEnableCmd = {WRITE_ENABLE_CMD};
        u8 ReadStatusCmd[] = {READ_STATUS_CMD, 0};
        u8 QuadEnableCmd[] = {WRITE_STATUS_CMD, 0, 0};
        u8 FlashStatus[2];

        if (FLASH_TYPE == SPANTION_TYPE || FLASH_TYPE == WINBOND_TYPE || FLASH_TYPE == MICRON_TYPE)  {
            XQspiPs_PolledTransfer(QspiPtr, ReadStatusCmd, FlashStatus, sizeof(ReadStatusCmd));
            QuadEnableCmd[1] = FlashStatus[1];
            QuadEnableCmd[2] = 0x02;
            XQspiPs_PolledTransfer(QspiPtr, &WriteEnableCmd, NULL, sizeof(WriteEnableCmd));
            XQspiPs_PolledTransfer(QspiPtr, QuadEnableCmd, NULL, sizeof(QuadEnableCmd));
        }
        else
        {
            while(1)
                if(Flag_Send_and_Recive_Serial!=1) {xil_printf("!!! FlashQuadEnable: Unsupported Flash Type !!!\r\n"); Delay_Xil_Printf;}
        }

    }
    void EEPROM1_Flash0_Read(uint16_t page_number, uint16_t sector_number, void* data, EEPROM_Mode_Type mode, uint32_t count, uint8_t MMC_1_Flash_0){
        uint16_t start_data=0;
        switch (mode){
            case MODE_8_BIT: break;
            case MODE_16_BIT: count=2*count; break;
            case MODE_32_BIT: count=4*count; break;
            case MODE_64_BIT: count=8*count; break;
        }

        if(MMC_1_Flash_0==1){
            int i;
            u8 dataRow[512]={0};
            read_from_MMC(dataRow, sector_number, 1);
            for(i=0; i<count; i++)
                *(((u8 *)data)+i)=dataRow[i];
        }
        else if(MMC_1_Flash_0==0){
            u8 WriteEnableCmd = { WRITE_ENABLE_CMD };
            u8 ReadStatusCmd[] = { READ_STATUS_CMD, 0 };
            u8 FlashStatus[2];

            //-----S: More Than 256
            if(page_number==1000){
                page_number=0;
                start_data=64*(sector_number % 4);
                sector_number=237+sector_number/4;
            }
            //-----E: More Than 256

            u32 Address = sector_number*SECTOR_SIZE + page_number * PAGE_SIZE;

            XQspiPs_PolledTransfer(&QspiInstance, &WriteEnableCmd, NULL, sizeof(WriteEnableCmd));

            if(FLASH_TYPE == SPANTION_TYPE)
                WriteBuffer[COMMAND_OFFSET]   = 0x17;
            else
                WriteBuffer[COMMAND_OFFSET]   = 0xC5;


            WriteBuffer[ADDRESS_1_OFFSET] = (u8)(Address >> 24);

            XQspiPs_PolledTransfer(&QspiInstance, WriteBuffer, NULL,2);
            while (1) {
                XQspiPs_PolledTransfer(&QspiInstance, ReadStatusCmd, FlashStatus,sizeof(ReadStatusCmd));
                if ((FlashStatus[1] & 0x01) == 0) {
                    break;
                }
            }

            WriteBuffer[COMMAND_OFFSET]   = READ_CMD;
            WriteBuffer[ADDRESS_1_OFFSET] = (u8)((Address & 0xFF0000) >> 16);
            WriteBuffer[ADDRESS_2_OFFSET] = (u8)((Address & 0xFF00) >> 8);
            WriteBuffer[ADDRESS_3_OFFSET] = (u8)(Address & 0xFF);
            XQspiPs_PolledTransfer(&QspiInstance, WriteBuffer, ReadBuffer, count + start_data + DATA_OFFSET);
            for(int i=start_data; i<count+start_data; i++){
                ((u8 *)data)[i-start_data]=ReadBuffer[i + DATA_OFFSET];
            }
        }
    }
    void Flash_Erase(uint16_t sector_address){
        FlashErase(&QspiInstance, sector_address);
    }
    void EEPROM1_Flash0_Write(uint16_t page_number, uint16_t sector_number, void* data_Write, EEPROM_Mode_Type mode, uint32_t count){
        int i;

        switch (mode){
            case MODE_8_BIT: break;
            case MODE_16_BIT: count=2*count; break;
            case MODE_32_BIT: count=4*count; break;
            case MODE_64_BIT: count=8*count; break;
        }

        if(page_number==1000){
            u8 dataRow[512] = {0};
            for(i=0; i<count; i++)
                dataRow[i]=*(((u8 *)data_Write)+i);
            Write_to_MMC(dataRow, sector_number, 1);
        }

        u8 data_256[256]={0};
        u8 Use_MainData=1;
        u8 WriteEnableCmd = { WRITE_ENABLE_CMD };
        u8 ReadStatusCmd[] = { READ_STATUS_CMD, 0 };
        u8 FlashStatus[2];

        //-----S: More Than 256
        if(page_number==1000){
            uint32_t start_data=0, IsEqual=1;
            EEPROM1_Flash0_Read(0, 237+sector_number/4, data_256, MODE_8_BIT, 256, 0);
            start_data=64*(sector_number % 4);

            for(i=0; i<count; i++){
                if(data_256[i+start_data]!=*(((u8 *)data_Write)+i)){
                    IsEqual=0;
                    data_256[i+start_data]=*(((u8 *)data_Write)+i);
                }
            }
            if(IsEqual==1){
                return;
            }
            page_number=0;
            count=256;
            sector_number=237+sector_number/4;
            Flash_Erase(sector_number);
            Use_MainData=0;
        }
        //-----E: More Than 256

        u32 Address = sector_number*SECTOR_SIZE + page_number * PAGE_SIZE;

        XQspiPs_PolledTransfer(&QspiInstance, &WriteEnableCmd, NULL, sizeof(WriteEnableCmd));

        if(FLASH_TYPE == SPANTION_TYPE)
            WriteBuffer[COMMAND_OFFSET]   = 0x17;
        else
            WriteBuffer[COMMAND_OFFSET]   = 0xC5;
        WriteBuffer[ADDRESS_1_OFFSET] = (u8)(Address >> 24);

        XQspiPs_PolledTransfer(&QspiInstance, WriteBuffer, NULL,2);
        while (1) {
            XQspiPs_PolledTransfer(&QspiInstance, ReadStatusCmd, FlashStatus,sizeof(ReadStatusCmd));
            if ((FlashStatus[1] & 0x01) == 0) {
                break;
            }
        }

        XQspiPs_PolledTransfer(&QspiInstance, &WriteEnableCmd, NULL, sizeof(WriteEnableCmd));
        WriteBuffer[COMMAND_OFFSET]   = WRITE_CMD;
        WriteBuffer[ADDRESS_1_OFFSET] = (u8)((Address & 0xFF0000) >> 16);
        WriteBuffer[ADDRESS_2_OFFSET] = (u8)((Address & 0xFF00) >> 8);
        WriteBuffer[ADDRESS_3_OFFSET] = (u8)(Address & 0xFF);
        for(int i=0; i<count; i++){
            if(Use_MainData==1)
                WriteBuffer[i+DATA_OFFSET]=((u8 *)data_Write)[i];
            else
                WriteBuffer[i+DATA_OFFSET]=((u8 *)data_256)[i];
        }
        XQspiPs_PolledTransfer(&QspiInstance, WriteBuffer, NULL, count + DATA_OFFSET);
        while (1) {
            XQspiPs_PolledTransfer(&QspiInstance, ReadStatusCmd, FlashStatus,sizeof(ReadStatusCmd));
            if ((FlashStatus[1] & 0x01) == 0) {
                break;
            }
        }
    }
    void EEPROM_Init(void){
        Onboard_eMMC_Init();
    }
    void Flash_Init(void){
        XQspiPs_Config *QspiConfig;
        QspiConfig = XQspiPs_LookupConfig(XPAR_XQSPIPS_0_DEVICE_ID);
        XQspiPs_CfgInitialize(&QspiInstance, QspiConfig, QspiConfig->BaseAddress);
        XQspiPs_SetOptions(&QspiInstance, XQSPIPS_MANUAL_START_OPTION | XQSPIPS_FORCE_SSELECT_OPTION | XQSPIPS_HOLD_B_DRIVE_OPTION);
        XQspiPs_SetClkPrescaler(&QspiInstance, XQSPIPS_CLK_PRESCALE_8);
        XQspiPs_SetSlaveSelect(&QspiInstance);
        FlashIdNum = FlashReadID();
        FLASH_TYPE = (u8)(FlashIdNum >> 8);
        FlashQuadEnable(&QspiInstance);
    }
    void Init_MMC_Flash_Check_Validity_If_First_Write_To_Flash(void){
        MMC_Flash_FlashOk1_FlashNotOk0=0;
        MMC_Flash_MMCOk1_MMChNotOk0=0;
        MMC_Flash_CompareOk1_CompareNotOk0=0;
        Adade_Khas_25_42_211_18[0]=0; Adade_Khas_25_42_211_18[1]=0; Adade_Khas_25_42_211_18[2]=0; Adade_Khas_25_42_211_18[3]=0;

        EEPROM_Init();

        EEPROMReadConfig();
        ReadMyCfg_Compare=ReadMyCfg;

        Flash_Init();

        uint32_t data_read_SSBL_Version[PAGE_SIZE/4];
        EEPROM1_Flash0_Read(LAST_SSBL_PAGE,LAST_SSBL_SECTOR_NUM, data_read_SSBL_Version,MODE_32_BIT,PAGE_SIZE/4, 0);
        for(int i=0; i<PAGE_NUM_IN_SECTOR/4; i++)
        {
            // evrytime we change SSBL Version we have to increase the maximum value here. base on C# SSBL_Version.
            if(data_read_SSBL_Version[i] >= 0x06 || data_read_SSBL_Version[i] <= 0x0B )
            {
                New_SSBL = data_read_SSBL_Version[i];
                break;
            }
            else
            {
                New_SSBL = 0;
                break;
            }
        }
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("2: During Code of Application Glb_Var_During_Test.New_SSBL= %d \r\n",New_SSBL); Delay_Xil_Printf;}

        EEPROM1_Flash0_Read(0, 236, Adade_Khas_25_42_211_18, MODE_8_BIT, 4, 0);
        if(Adade_Khas_25_42_211_18[0]==25 && Adade_Khas_25_42_211_18[1]==42 && Adade_Khas_25_42_211_18[2]==211 && Adade_Khas_25_42_211_18[3]==18)
            MMC_Flash_FlashOk1_FlashNotOk0=1;
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("MMC_Flash_FlashOk1_FlashNotOk0=%d \r\n",MMC_Flash_FlashOk1_FlashNotOk0); Delay_Xil_Printf;}

        EEPROMReadConfig();

        MMC_Flash_CompareOk1_CompareNotOk0=1;
        for(int mmm=0; mmm<sizeof(ReadMyCfg); mmm++){
            if(*(((uint8_t *)&ReadMyCfg_Compare.startData)+mmm)!=*(((uint8_t *)&ReadMyCfg.startData)+mmm)){
                MMC_Flash_CompareOk1_CompareNotOk0=0;
                if(Flag_Send_and_Recive_Serial!=1) {xil_printf("Tafavot Dar Flash MMC Byte:%d    Flash: %d      MMC: %d\r\n", mmm, *(((uint8_t *)&ReadMyCfg.startData)+mmm), *(((uint8_t *)&ReadMyCfg_Compare.startData)+mmm)); Delay_Xil_Printf;}
            }
        }

        if(MMC_Flash_FlashOk1_FlashNotOk0==0)
        {
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("Man Omadam to if  %d \r\n",Adade_Khas_25_42_211_18[0]); Delay_Xil_Printf;}
            Adade_Khas_25_42_211_18[0]=25;
            Adade_Khas_25_42_211_18[1]=42;
            Adade_Khas_25_42_211_18[2]=211;
            Adade_Khas_25_42_211_18[3]=18;
            Flash_Erase(236);
            EEPROM1_Flash0_Write(0, 236, Adade_Khas_25_42_211_18, MODE_8_BIT, 4);
            ReadMyCfg=ReadMyCfg_Compare;
            EEPROMWriteConfig(WriteMode_All, 1);
        }
        else{
            if(Flag_Send_and_Recive_Serial!=1) {xil_printf("Man Birooooon if  %d \r\n",Adade_Khas_25_42_211_18[0]); Delay_Xil_Printf;}
        }
        usleep(10000);

    }
#endif  //----------------------   E: Flash
#if(1)  //----------------------   S: SPI
    void SSP_Init(uint8_t SSPx, uint32_t ClockRate){
        uint32_t zarib=    52000000;
        if(SSPx == LPC_SSP0){
            Set_Main_IP(SPI0_Freq_SV21, zarib / ClockRate);
        }
        else if(SSPx == LPC_SSP1){
            Set_Main_IP(SPI1_Freq_SV26 , zarib / ClockRate);
        }
    }
    uint16_t SSP_ReceiveData(uint8_t SSPx){
        u16 ret=0;
        if(SSPx == LPC_SSP0){
            ret = (uint16_t)AssignFromSV_Single_data(W_I_SPI0_Rec);
        }
        else if(SSPx== LPC_SSP1){
            ret =  (uint16_t)AssignFromSV_Single_data(W_I_SPI1_Rec);
        }
        return ret;
    }
    void SSP_SendData(uint8_t SSPx, uint16_t Data){
        static uint32_t Set_SPI0_Start=0, Set_SPI1_Start=0;
        if(SSPx == LPC_SSP0){
            Set_Main_IP(SPI0_Send_SV22, Data);
            Set_SPI0_Start++;
            Set_Main_IP(SPI0_Start_SV24, Set_SPI0_Start);
        }
        else if(SSPx== LPC_SSP1){
            Set_Main_IP(SPI1_Send_SV27, Data);
            Set_SPI1_Start++;
            Set_Main_IP(SPI1_Start_SV29, Set_SPI1_Start);
        }
    }
    uint8_t IsBusy(uint8_t SSPx){
        u8 ret=0;
        if(SSPx == LPC_SSP0){
            ret = AssignFromSV_Single_data(W_I_SPI0_Busy);
        }
        else if(SSPx== LPC_SSP1){
            ret = AssignFromSV_Single_data(W_I_SPI1_Busy);
        }
        return ret;
    }
#endif  //----------------------   E: SPI
#if(1)  //----------------------   S: I2C
#endif  //----------------------   E: I2C
#if(1)  //----------------------   S: Watchdog
    int8_t WWDT_Start(uint32_t TimeOut){
        if(EnableWDTY==1){
            XScuWdt_LoadWdt(&Watchdog, TimeOut);
            XScuWdt_Start(&Watchdog);
        }
        return 0;
    }
    void WWDT_Feed (void){
        if(EnableWDTY==1){
            XScuWdt_RestartWdt(&Watchdog);
        }
    }
    void WWDT_FeedStdSeq (void){
        if(EnableWDTY==1){
            XScuWdt_RestartWdt(&Watchdog);
        }
    }
    void WDT_Init(void){
        if(EnableWDTY==1){
            WDT_ConfigPtr = XScuWdt_LookupConfig(XPAR_SCUWDT_0_DEVICE_ID);
            XScuWdt_CfgInitialize(&Watchdog, WDT_ConfigPtr,WDT_ConfigPtr->BaseAddr);
            XScuWdt_SetWdMode(&Watchdog);
            XScuWdt_LoadWdt(&Watchdog, WDT_LOAD_VALUE);
            XScuWdt_Start(&Watchdog);
        }
    }
#endif  //----------------------   E: Watchdog
#if(1)  //----------------------   S: GPIO
    void GPIO_Init(void){
        GPIOConfigPtr = XGpioPs_LookupConfig(XPAR_XGPIOPS_0_DEVICE_ID);
        XGpioPs_CfgInitialize(&xGpioPs, GPIOConfigPtr, GPIOConfigPtr->BaseAddr);

        XGpioPs_SetDirectionPin(&xGpioPs, MIO_PS_500_RESET_OUTn, 1);
        XGpioPs_SetOutputEnablePin(&xGpioPs, MIO_PS_500_RESET_OUTn, 1);

        XGpioPs_SetDirectionPin(&xGpioPs, EMIO_DP83_RESET, 1);
        XGpioPs_SetOutputEnablePin(&xGpioPs, EMIO_DP83_RESET, 1);
    }
    void GPIO_Peripheral_IC_Reset(void){
        XGpioPs_WritePin(&xGpioPs, MIO_PS_500_RESET_OUTn, 0);
        XGpioPs_WritePin(&xGpioPs, EMIO_DP83_RESET, 0);
        usleep(100);
        XGpioPs_WritePin(&xGpioPs, MIO_PS_500_RESET_OUTn, 1);
        XGpioPs_WritePin(&xGpioPs, EMIO_DP83_RESET, 1);
    }
#endif  //----------------------   E: GPIO
#if(1)  //----------------------   S: Temperature Monitoring
    int XAdcFractionToInt(float FloatNum)
    {
        float Temp;

        Temp = FloatNum;
        if (FloatNum < 0) {
            Temp = -(FloatNum);
        }

        return( ((int)((Temp -(float)((int)Temp)) * (1000.0f))));
    }
    void TempMonitoring(void){
        u32 TempRawData;
        float TempData;
        float MaxData;
        float MinData;
        XAdcPs *XAdcInstPtr = &XAdcInst;

        TempRawData = XAdcPs_GetAdcData(XAdcInstPtr, XADCPS_CH_TEMP);
        TempData = XAdcPs_RawToTemperature(TempRawData);
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("\r\n############## Temp ############\r\n"); Delay_Xil_Printf;}
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("The Current Temperature is %0d.%03d Centigrades.\r\n", (int)(TempData), XAdcFractionToInt(TempData)); Delay_Xil_Printf;}


        TempRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr, XADCPS_MAX_TEMP);
        MaxData = XAdcPs_RawToTemperature(TempRawData);
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("The Maximum Temperature is %0d.%03d Centigrades. \r\n", (int)(MaxData), XAdcFractionToInt(MaxData)); Delay_Xil_Printf;}

        TempRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr, XADCPS_MIN_TEMP);
        MinData = XAdcPs_RawToTemperature(TempRawData & 0xFFF0);
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("The Minimum Temperature is %0d.%03d Centigrades. \r\n", (int)(MinData), XAdcFractionToInt(MinData)); Delay_Xil_Printf;}
    }
#endif  //----------------------   E: Temperature Monitoring
#if(1)  //----------------------   S: CPU Starting
#endif  //----------------------   E: CPU Starting
#if(1)  //----------------------   S: Set For Bootloader
    u8 getJumptoApp(){
        return (Xil_In32(0xF800702C) >> 24);
    }
    u8 getNeedforUpdate(){
        return (Xil_In32(0xF800702C) >> 20)  & (~(0xFF << 4));
    }
    u8 getDongleFlag(){
        return (Xil_In32(0xF800702C) >> 16)  & (~(0xFFF << 4));
    }
    void clearJumptoApp(){
        Xil_Out32(0xF800702C, Xil_In32(0xF800702C) & (~(0xFF << 24)));  // JumptoApp = 0
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("@@@@@@@@@ App: JumpToApp clear to %x\n",(Xil_In32(0xF800702C) >> 24)); Delay_Xil_Printf;}
    }
    void setJumptoApp(){
        clearJumptoApp();
        Xil_Out32(0xF800702C,Xil_In32(0xF800702C) | (0x4A << 24));   // JumptoApp = 'J'
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("@@@@@@@@@ SSBL: JumpToApp set to %x\n",(Xil_In32(0xF800702C) >> 24)); Delay_Xil_Printf;}
    }
    void incrementJumptoApp(){
        JumpToApplication = (Xil_In32(0xF800702C) >> 24);
        JumpToApplication = JumpToApplication + 1;
        clearJumptoApp();
        Xil_Out32(0xF800702C,(Xil_In32(0xF800702C) | (JumpToApplication) << 24));   // JumptoApp++
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("@@@@@@@@@ SSBL: JumpToApp is incremented to %x\n",(Xil_In32(0xF800702C) >> 24)); Delay_Xil_Printf;}
    }
    void clearNeedforUpdate(){
        Xil_Out32(0xF800702C,Xil_In32(0xF800702C) & (~(0x00F << 20)));    // NeedforUpdate = 0
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("@@@@@@@@@ SSBL: NeedForUpdate clear to %x\n",(Xil_In32(0xF800702C) >> 20)  & (~(0xFF << 4))); Delay_Xil_Printf;}
    }
    void setNeedforUpdate(){
        clearNeedforUpdate();
        Xil_Out32(0xF800702C,Xil_In32(0xF800702C) | (0x00A << 20));    // NeedforUpdate = 0xA
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("@@@@@@@@@ SSBL: NeedForUpdate set to %x\n",(Xil_In32(0xF800702C) >> 20)  & (~(0xFF << 4))); Delay_Xil_Printf;}
    }
    void clearDongleFlag(){
        Xil_Out32(0xF800702C,Xil_In32(0xF800702C) & (~(0x000F << 16)));    // NeedforUpdate = 0
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("@@@@@@@@@ SSBL: DongleFlag clear to %x\n",(Xil_In32(0xF800702C) >> 16)  & (~(0xFFF << 4))); Delay_Xil_Printf;}
    }
    void setDongleFlag(){
        clearDongleFlag();
        Xil_Out32(0xF800702C,Xil_In32(0xF800702C) | (0x0005 << 16));   // JumptoApp = 5
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("@@@@@@@@@ SSBL: DongleFlag set to %x\n",(Xil_In32(0xF800702C) >> 16)  & (~(0xFFF << 4))); Delay_Xil_Printf;}
    }
#endif  //----------------------   E: Set For Bootloader
#if(1)  //----------------------   S: Share Memory
    void Reset_Share_DDR_Mem_Values(void){
        uint32_t i = 0U;

        Glb_common_PS0_PS1->StartPs1 = 0;

        for(i=0U; i<sizeof(Glb_common_PS0_PS1->MAC); i++){
            Glb_common_PS0_PS1->MAC[i] = 0;
        }

        for(i=0U; i<sizeof(Glb_common_PS0_PS1->IPConfig); i++){
            Glb_common_PS0_PS1->IPConfig[i] = 0;
        }

        Glb_common_PS0_PS1->Port = 0;

        Glb_common_PS0_PS1->Connected = 0;

        Glb_common_PS0_PS1->NumberOfByteRecieve = 0;

        for(i=0U; i<sizeof(Glb_common_PS0_PS1->RecieveLan); i++){
            Glb_common_PS0_PS1->RecieveLan[i] = 0;
        }

        Glb_common_PS0_PS1->NumberOfByteSend = 0;

        for(i=0U; i<sizeof(Glb_common_PS0_PS1->SendLan); i++){
            Glb_common_PS0_PS1->SendLan[i] = 0;
        }

        Glb_common_PS0_PS1->StartForDefault = 0;

        Glb_common_PS0_PS1->EmacDataLenSend = 0;

        for(i=0U; i<sizeof(Glb_common_PS0_PS1->EmacDataSend); i++){
            Glb_common_PS0_PS1->EmacDataSend[i] = 0;
        }

        Glb_common_PS0_PS1->EmacDataLenReciev = 0;

        for(i=0U; i<sizeof(Glb_common_PS0_PS1->EmacDataReciev); i++){
            Glb_common_PS0_PS1->EmacDataReciev[i] = 0;
        }
    }
#endif  //----------------------   E: Share Memory
#if(1)  //----------------------   S: AXI Memory
    void Set_Main_IP(Main_IP_Enum IP_Number, uint32_t value){
        *(uint32_t *)(Main_IP+4*IP_Number)=value;
    }
#endif  //----------------------   E: AXI Memory
#if(1)  //----------------------   S: OCM Read Write Memory
#endif  //----------------------   E: OCM Read Write Memory
#if(1)  //----------------------   S: Soft UART Print For Linux
//    /*
//     * Function to send data to OCM which is consumed by Linux Application
//     */
//    void myPutchar(char c) {
//
//        while(Glb_common_PS0_PS1->SoftUart_Flag);    //wait for cpu0 to consume previous value
//        Glb_common_PS0_PS1->SoftUart_Data = (volatile unsigned long)c;
//        dmb();
//        Glb_common_PS0_PS1->SoftUart_Flag = 1;
//
//    }
//
//    /*
//     * Since there is no STDIO assigned to the BSP, outbyte() is not created
//     * by libgen. So add outbyte() call to myPutchar() to enable STDOUT functionality
//     */
//    void outbyte(char c) {
//        myPutchar(c);
//    }
#endif  //----------------------   S: Soft UART Print For Linux
#if(1)  //----------------------   S: Write To Flash For Bootloader
    void Change_To_Default(void){
        if(Flag_Send_and_Recive_Serial!=1) {xil_printf("Change to default has been called.\r\n"); Delay_Xil_Printf;}
        ReadMyCfg.IPConfig[0]=192;
        ReadMyCfg.IPConfig[1]=168;
        ReadMyCfg.IPConfig[2]=1;
        ReadMyCfg.IPConfig[3]=199;
        ReadMyCfg.IPConfig[4]=192;
        ReadMyCfg.IPConfig[5]=168;
        ReadMyCfg.IPConfig[6]=1;
        ReadMyCfg.IPConfig[7]=1;
        ReadMyCfg.IPConfig[8]=255;
        ReadMyCfg.IPConfig[9]=255;
        ReadMyCfg.IPConfig[10]=255;
        ReadMyCfg.IPConfig[11]=0;
        ReadMyCfg.IPConfig[12]=192;
        ReadMyCfg.IPConfig[13]=168;
        ReadMyCfg.IPConfig[14]=1;
        ReadMyCfg.IPConfig[15]=1;
        ReadMyCfg.Port=1001;
        ReadMyCfg.MAC[0]=0x1E;
        ReadMyCfg.MAC[1]=0x30;
        ReadMyCfg.MAC[2]=0x6C;
        ReadMyCfg.MAC[3]=0xA2;
        ReadMyCfg.MAC[4]=0x45;
        ReadMyCfg.MAC[5]=0x5E;
    }
    void Tester_Init_for_Destroying_SSBL(void){
        NVIC_Init();
        UART_Init_Parameters(UART_0, 115200, XUARTPS_FORMAT_8_BITS, XUARTPS_FORMAT_NO_PARITY, XUARTPS_FORMAT_1_STOP_BIT);
        if(Glb_common_PS0_PS1->StartForDefault==123 || ReadMyCfg.IPConfig[0]==0 ||ReadMyCfg.Port==0 || ReadMyCfg.IPConfig[0]==255 ||ReadMyCfg.Port==65536 || ReadMyCfg.Port==65535 || (ReadMyCfg.Port==23899 &&  ReadMyCfg.IPConfig[0]==71 ) || (ReadMyCfg.MAC[0]==0 && ReadMyCfg.MAC[1]==0 && ReadMyCfg.MAC[2]==0 && ReadMyCfg.MAC[3]==0 && ReadMyCfg.MAC[4]==0 && ReadMyCfg.MAC[5]==0) || (ReadMyCfg.MAC[0]==0xFF && ReadMyCfg.MAC[1]==0xFF && ReadMyCfg.MAC[2]==0xFF && ReadMyCfg.MAC[3]==0xFF && ReadMyCfg.MAC[4]==0xFF && ReadMyCfg.MAC[5]==0xFF)){
            Change_To_Default();
        }
        Ethernet_Init();
    }
    void Variable_Init(void){
        Set_Main_IP(slv_reg100, 0);
        Set_Main_IP(slv_reg101, 0);
        Set_Main_IP(slv_reg102, 0);
        Set_Main_IP(slv_reg103, 0);
        Set_Main_IP(slv_reg104, 0);
        Set_Main_IP(slv_reg105, 0);
        Set_Main_IP(slv_reg106, 0);
        Set_Main_IP(slv_reg107, 0);
        Set_Main_IP(slv_reg108, 0);

        Set_Main_IP(ADConfig_SV90, 1);
        Set_Main_IP(LED_Cheshmak_1_SV251, 2000);
        Set_Main_IP(LED_Cheshmak_2_SV252, 1000);
        Set_Main_IP(LED_Cheshmak_3_SV253, 250) ;
        Set_Main_IP(LED_Number_of_Total_SV244, 60);
        Set_Main_IP(LED_Delay_SV64, 10000);
        MMC_Flash_FlashOk1_FlashNotOk0     = 0    ;
        MMC_Flash_MMCOk1_MMChNotOk0        = 0    ;
        Total_len_QSPI=0;
        writing_index=0;
        Total_packet_count = 0;
        Flag_Bootloader=-1;
        Flag_linux=-1;
        CompressedImagetExist=-1;
        Packet_Count_QSPI             = 0;
        Sector_Count_LinuxConfig      = 0;
        Sector_Count_LinuxImage       = 0;
        Sector_Count_LinuxDispatcher  = 0;
        Sector_Count_LinuxOverlay     = 0;
        Sector_Count_LinuxKernel      = 0;
        write_count                   = 0;
        write_flag                    = 0;
        CounterWhile                  =1000000;
        FinalPacketFlag               =0;
        uartSend                      =0x74;
        UART0_Init_Var                =0;
        Flag_WriteMode_OnlyIPConfigWithoutSerial_For_Goose_Because_In_Goose_System_Reset=0;

        for(int i=0; i<=60; i++)
            SetLEDcolor(i,0,0,0);
        Set_ALL_LED_Color_To_FPGA();
    }
#endif  //----------------------   E: Write To Flash For Bootloader
